#!/usr/bin/env python

from __future__ import print_function

import argparse
import logging
import pprint
import os
import sys
import re

import json

import shlex

__prog__ = os.path.basename(__file__)
if __prog__.endswith('.py'):
    __prog__ = __prog__[:-3]

__version__ = '0.0.1'


class CompilationDatabaseRegistry(type):
    def __init__(cls, name, bases, nmspc):
        super(CompilationDatabaseRegistry, cls).__init__(name, bases, nmspc)
        if not hasattr(cls, 'registry'):
            cls.registry = set()
        if len(bases) > 0:  # skip the base class
            cls.registry.add(cls)

    def __iter__(cls):
        return iter(cls.registry)

    def __str__(cls):
        if cls in cls.registry:
            return cls.__name__
        return cls.__name__ + ": " + ", ".join([sc.__name__ for sc in cls])


if sys.version_info[0] < 3:

    class RegisteredCompilationDatabase():
        __metaclass__ = CompilationDatabaseRegistry
else:
    # Probably a bad idea but the syntax is incompatible in python2
    exec(
        'class RegisteredCompilationDatabase(metaclass=CompilationDatabaseRegistry): pass')


# could be an "interface"
class CompileCommand:
    def __init__(self, directory, file, command):
        self.directory = directory
        self.file = file
        self.command = command

    def __repr__(self):
        return "{{directory: {},\nfilename: {},\n command: ".format(
            self.directory, self.file) + pprint.pformat(self.command) + "}\n\n"

    def __str__(self):
        return self.__repr__()


class CompilationDatabase(RegisteredCompilationDatabase):
    """Mimic clang::tooling::CompilationDatabase interface"""

    @staticmethod
    def from_directory(directory):
        """Automatically create a CompilationDatabase from build directory."""
        # TODO: user should be able to order the compilation databases
        for cdb_cls in CompilationDatabase:
            if cdb_cls == CompilationDatabase:
                # skip ourselves from the class list
                continue
            cdb = cdb_cls.from_directory(directory)
            if cdb:
                return cdb
        return None

    def get_compile_commands(self, filepath):
        """get the compile commands for the given file

        return an iterable of CompileCommand
        """
        raise NotImplementedError()

    def get_all_files(self):
        """return an iterable of path strings"""
        raise NotImplementedError()

    def get_all_compile_commands(self):
        """return an iterable of CompileCommand"""
        raise NotImplementedError()


class JSONCompilationDatabase(CompilationDatabase):
    def __init__(self, json_db_path):
        self.json_db_path = json_db_path

    @classmethod
    def from_directory(cls, directory):
        json_db_path = os.path.join(directory, 'compile_commands.json')
        return cls(json_db_path) if os.path.exists(json_db_path) else None

    def get_compile_commands(self, filepath):
        commands = []
        for elem in self._data:
            if elem['file'] == filepath:
                commands.append(self._dict_to_compile_command(elem))
        return commands

    def get_all_files(self):
        return map((lambda entry: entry['file']), self._data)

    def get_all_compile_commands(self):
        # PERFORMANCE: I think shlex is inherently slow,
        # something performing better may be necessary
        return list(map(self._dict_to_compile_command, self._data))

    @staticmethod
    def _dict_to_compile_command(d):
        return CompileCommand(d['directory'], d['file'],
                              shlex.split(d['command']))

    @property
    def _data(self):
        if not hasattr(self, '__data'):
            with open(self.json_db_path) as f:
                self.__data = json.load(f)
        return self.__data


# http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html#example-self-registration-of-subclasses
class CommandRegistry(type):
    def __init__(cls, name, bases, nmspc):
        super(CommandRegistry, cls).__init__(name, bases, nmspc)
        if not hasattr(cls, 'registry'):
            cls.registry = set()
        if len(bases) > 0:  # skip the base class
            cls.registry.add(cls)

    def __iter__(cls):
        return iter(cls.registry)

    def __str__(cls):
        if cls in cls.registry:
            return cls.__name__
        return cls.__name__ + ": " + ", ".join([sc.__name__ for sc in cls])


if sys.version_info[0] < 3:

    class RegisteredCommand():
        __metaclass__ = CommandRegistry
else:
    # Probably a bad idea but the syntax is incompatible in python2
    exec('class RegisteredCommand(metaclass=CommandRegistry): pass')


class HelpCommand(RegisteredCommand):
    name = 'help'
    short_help = 'display this help'

    def execute(self, args):
        print("Available commands:")
        commands = sorted(RegisteredCommand, key=lambda c: c.name)
        command_max_len = max(map(len, [c.name for c in commands]))
        for c in commands:
            print("    {c.name:<{max_len}}   {c.short_help}".format(
                c=c,
                max_len=command_max_len))


class VersionCommand(RegisteredCommand):
    name = 'version'
    short_help = 'display this version of {}'.format(__prog__)

    def options(self, parser):
        parser.add_argument('--short',
                            action='store_true',
                            help='machine readable version')

    def execute(self, args):
        if args.short:
            print(__version__)
        else:
            print(__prog__, "version", __version__)


def command_to_json(commands):
    cmd_line = '"'
    for i, command in enumerate(commands):
        if i != 0:
            cmd_line += ' '
        has_space = re.search(r"\s", command) is not None
        # reader now accepts simple quotes, so we need to support them here too
        has_simple_quote = "'" in command
        need_quoting = has_space or has_simple_quote
        if need_quoting:
            cmd_line += r'\"'
        cmd_line += command.replace("\\", r'\\\\').replace(r'"', r'\\\"')
        if need_quoting:
            cmd_line += r'\"'
    return cmd_line + '"'


def str_to_json(s):
    return '"{}"'.format(s.replace("\\", "\\\\").replace('"', r'\"'))


def compile_command_to_json(compile_command):
    return r'''{{
  "directory": {},
  "command": {},
  "file": {}
}}'''.format(
        str_to_json(compile_command.directory),
        command_to_json(compile_command.command),
        str_to_json(compile_command.file))


def compile_commands_to_json(compile_commands, fp):
    """
    Dump Json.

    Parameters
    ----------
    compile_commands : CompileCommand iterable
    fp
        A file-like object, JSON is written to this element.
    """
    fp.write('[\n')
    for i, command in enumerate(compile_commands):
        if i != 0:
            fp.write(',\n\n')
        fp.write(compile_command_to_json(command))
    if compile_commands:
        fp.write('\n')
    fp.write(']\n')


class DumpCommand(RegisteredCommand):
    name = 'dump'
    short_help = 'dump a compilation database'

    def options(self, parser):
        parser.add_argument('-p',
                            metavar="BUILD-DIR",
                            help='Build path',
                            required=True)

    def execute(self, args):
        build_dir = args.p
        cdb = CompilationDatabase.from_directory(build_dir)
        if not cdb:
            return
        self.json_dump(cdb.get_all_compile_commands())

    def json_dump(self, compile_commands):
        print(json.dumps(compile_commands,
                         cls=CompilationDatabaseJSONEncoder,
                         indent=2))


# remove the redundant metavar from help output
#
#     usage: foo <sub-parser metavar>
#
#     <sub-parser title>:
#       <sub-parser metavar>            # <- remove this
#         command_a      a description
#         command_b      b description
#
# http://stackoverflow.com/a/13429281/951426
class SubcommandHelpFormatter(argparse.RawDescriptionHelpFormatter):
    def _format_action(self, action):
        parts = super(argparse.RawDescriptionHelpFormatter,
                      self)._format_action(action)
        if action.nargs == argparse.PARSER:
            parts = "\n".join(parts.split("\n")[1:])
        return parts


class App:
    def __init__(self):
        self.parser = argparse.ArgumentParser(
            description='A compilation database helper tool.',
            formatter_class=SubcommandHelpFormatter)

        # http://stackoverflow.com/a/18283730/951426
        # http://bugs.python.org/issue9253#msg186387
        subparsers = self.parser.add_subparsers(title='Available commands',
                                                metavar='<command>',
                                                dest='command')
        subparsers.dest = 'command'
        # subcommand seems to be required by default in python 2.7 but not 3.5,
        # forcing it to true limit the differences between the two
        subparsers.required = True

        commands = []
        for command_cls in RegisteredCommand:
            command = command_cls()
            commands.append(command)
            parser = subparsers.add_parser(command.name,
                                           help=command.short_help)
            if callable(getattr(command_cls, 'options', None)):
                command.options(parser)
            parser.set_defaults(func=command.execute)

    def run(self):
        # if no option is specified we default to "help" so we have something
        # useful to show to the user instead of an error because of missing
        # subcommand
        args = self.parser.parse_args(sys.argv[1:] or ["help"])
        args.func(args)


if __name__ == '__main__':
    app = App()
    app.run()
